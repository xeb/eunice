<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EUNICE</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #fafafa;
            --bg-card: #ffffff;
            --bg-input: #f5f5f5;
            --text: #1a1a1a;
            --text-muted: #888888;
            --border: #e0e0e0;
            --border-strong: #1a1a1a;
            --neon-cyan: #00e5ff;
            --neon-magenta: #ff00ff;
            --neon-coral: #ff6b6b;
            --neon-mint: #00ffaa;
            --neon-yellow: #ffee00;
            --grid-line: rgba(0,0,0,0.03);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background-image:
                linear-gradient(var(--grid-line) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        .container {
            max-width: 900px;
            width: 100%;
            margin: 0 auto;
            padding: 0 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        header {
            padding: 24px 0 16px;
            border-bottom: 1px solid var(--border-strong);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-top {
            gap: 12px;
        }

        .header-spacer {
            flex: 1;
        }

        .header-info-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        .logo {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: 0.3em;
            color: var(--text);
        }

        .status {
            display: flex;
            align-items: center;
            gap: 16px;
            font-size: 12px;
        }

        .model-badge {
            padding: 4px 10px;
            border: 1px solid var(--border-strong);
            font-weight: 500;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--neon-mint);
        }

        .status-dot.disconnected {
            background: var(--neon-coral);
        }

        .status-dot.loading {
            background: var(--neon-yellow);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Messages */
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 24px 0;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .message {
            padding: 12px 16px;
            border-left: 3px solid transparent;
            background: var(--bg-card);
            animation: slideIn 0.15s ease-out;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .message.user {
            border-left-color: var(--border-strong);
        }

        .message.user::before {
            content: '> ';
            color: var(--text-muted);
        }

        .message.thinking {
            border-left-color: var(--neon-yellow);
            color: var(--text-muted);
        }

        .message.thinking .cursor {
            display: inline-block;
            animation: blink 0.5s step-end infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .message.tool-call {
            border-left-color: var(--neon-cyan);
        }

        .tool-name {
            font-weight: 600;
            color: var(--text);
        }

        .tool-agent {
            font-size: 11px;
            color: var(--neon-magenta);
            font-weight: 500;
        }

        .tool-args {
            color: var(--text-muted);
            font-size: 13px;
            margin-top: 4px;
            word-break: break-all;
        }

        .message.tool-result {
            border-left-color: var(--neon-mint);
        }

        .tool-result-content {
            white-space: pre-wrap;
            font-size: 13px;
            max-height: 200px;
            overflow-y: auto;
        }

        .tool-result-content.collapsed {
            max-height: 100px;
        }

        /* Agent invocation styles (multi-agent mode) */
        .message.agent-invoke {
            border-left-color: var(--neon-magenta);
            background: linear-gradient(90deg, rgba(230, 0, 126, 0.1) 0%, transparent 100%);
        }

        .message.agent-result {
            border-left-color: var(--neon-mint);
            background: linear-gradient(90deg, rgba(0, 255, 163, 0.1) 0%, transparent 100%);
        }

        .agent-icon {
            margin-right: 6px;
        }

        .agent-label {
            color: var(--text-muted);
            font-size: 12px;
            margin-right: 6px;
        }

        .agent-name {
            font-weight: 600;
            color: var(--neon-magenta);
        }

        .agent-task {
            color: var(--text-muted);
            font-size: 13px;
            margin-top: 4px;
            font-style: italic;
        }

        .agent-result-content {
            white-space: pre-wrap;
            font-size: 13px;
            margin-top: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .truncated-notice {
            color: var(--text-muted);
            font-size: 12px;
            margin-top: 8px;
            cursor: pointer;
        }

        .truncated-notice:hover {
            color: var(--neon-cyan);
        }

        .message.response {
            border-left-color: transparent;
            white-space: pre-wrap;
        }

        .message.error {
            border-left-color: var(--neon-coral);
            color: var(--neon-coral);
        }

        .message.system {
            border-left-color: var(--neon-yellow);
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Input Area */
        .input-area {
            padding: 16px 0 24px;
            border-top: 1px solid var(--border);
        }

        .input-wrapper {
            display: flex;
            gap: 12px;
        }

        .query-input {
            flex: 1;
            padding: 12px 16px;
            font-family: inherit;
            font-size: 14px;
            border: 1px solid var(--border-strong);
            background: var(--bg-input);
            color: var(--text);
            resize: none;
            min-height: 48px;
            max-height: 150px;
            transition: box-shadow 0.1s;
        }

        .query-input:focus {
            outline: none;
            box-shadow: 0 0 0 2px var(--neon-cyan);
        }

        .query-input::placeholder {
            color: var(--text-muted);
        }

        .btn {
            padding: 12px 24px;
            font-family: inherit;
            font-size: 14px;
            font-weight: 600;
            border: 1px solid var(--border-strong);
            cursor: pointer;
            transition: all 0.1s;
        }

        .btn-primary {
            background: var(--text);
            color: var(--bg);
        }

        .btn-primary:hover {
            background: #333;
        }

        .btn-primary:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
        }

        .btn-cancel {
            background: var(--bg);
            color: var(--neon-coral);
            border-color: var(--neon-coral);
            display: none;
        }

        .btn-cancel.visible {
            display: block;
        }

        .btn-cancel:hover {
            background: var(--neon-coral);
            color: var(--bg);
        }

        /* Status Bar */
        .status-bar {
            padding: 12px 0;
            border-top: 1px solid var(--border);
            font-size: 12px;
            color: var(--text-muted);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .status-bar span::after {
            content: ' \25C6';
            margin-left: 8px;
        }

        .status-bar span:last-child::after {
            content: '';
        }

        .mode-badge {
            font-weight: 600;
            color: var(--text);
        }

        .header-info {
            font-size: 11px;
            color: var(--text-muted);
            padding: 2px 6px;
            border: 1px solid var(--border);
        }

        /* API Button */
        .btn-api {
            padding: 4px 10px;
            font-size: 12px;
            background: transparent;
            border: 1px solid var(--border-strong);
            cursor: pointer;
            font-family: inherit;
            font-weight: 500;
        }

        .btn-api:hover {
            background: var(--text);
            color: var(--bg);
        }

        .btn-new {
            background: var(--neon-mint);
            color: var(--bg);
            border-color: var(--neon-mint);
        }

        /* Hamburger Menu Button */
        .btn-menu {
            background: none;
            border: 1px solid var(--border-strong);
            padding: 4px 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-menu:hover {
            background: var(--text);
            color: var(--bg);
        }

        .btn-menu svg {
            width: 16px;
            height: 16px;
        }

        /* Session Drawer */
        .session-drawer {
            position: fixed;
            top: 0;
            left: -320px;
            width: 300px;
            height: 100vh;
            background: var(--bg-card);
            border-right: 1px solid var(--border-strong);
            z-index: 1001;
            transition: left 0.2s ease-out;
            display: flex;
            flex-direction: column;
        }

        .session-drawer.open {
            left: 0;
        }

        .drawer-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            display: none;
        }

        .drawer-overlay.visible {
            display: block;
        }

        .drawer-header {
            padding: 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .drawer-title {
            font-weight: 700;
            letter-spacing: 0.2em;
            font-size: 12px;
        }

        .btn-new-session {
            padding: 4px 10px;
            font-size: 11px;
            background: var(--neon-mint);
            color: var(--bg);
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-weight: 600;
        }

        .btn-new-session:hover {
            opacity: 0.8;
        }

        .session-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
        }

        .session-item {
            padding: 12px 16px;
            cursor: pointer;
            border-left: 3px solid transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .session-item:hover {
            background: var(--bg-input);
        }

        .session-item.active {
            border-left-color: var(--neon-cyan);
            background: var(--bg-input);
        }

        .session-info {
            flex: 1;
            min-width: 0;
        }

        .session-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .session-meta {
            font-size: 11px;
            color: var(--text-muted);
        }

        .session-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px 8px;
            font-size: 16px;
            line-height: 1;
        }

        .session-delete:hover {
            color: var(--neon-coral);
        }

        .drawer-footer {
            padding: 12px 16px;
            border-top: 1px solid var(--border);
            font-size: 10px;
            color: var(--text-muted);
        }

        .persistence-badge {
            background: var(--neon-mint);
            color: var(--bg);
            padding: 2px 6px;
            font-weight: 600;
        }

        .persistence-badge.memory {
            background: var(--neon-yellow);
        }

        .no-sessions {
            padding: 20px 16px;
            color: var(--text-muted);
            font-size: 12px;
            text-align: center;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-overlay.visible {
            display: flex;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border-strong);
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            padding: 24px;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border);
        }

        .modal-title {
            font-size: 16px;
            font-weight: 700;
            letter-spacing: 0.1em;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-muted);
            font-family: inherit;
        }

        .modal-close:hover {
            color: var(--text);
        }

        .api-endpoint {
            margin-bottom: 24px;
        }

        .api-endpoint h3 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .api-method {
            padding: 2px 6px;
            font-size: 11px;
            font-weight: 600;
        }

        .api-method.get {
            background: var(--neon-mint);
            color: var(--text);
        }

        .api-method.post {
            background: var(--neon-cyan);
            color: var(--text);
        }

        .api-endpoint p {
            color: var(--text-muted);
            font-size: 13px;
            margin-bottom: 12px;
        }

        .api-curl {
            background: var(--bg-input);
            border: 1px solid var(--border);
            padding: 12px;
            font-size: 12px;
            overflow-x: auto;
            white-space: pre;
        }

        .api-response {
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-muted);
        }

        .api-response summary {
            cursor: pointer;
            margin-bottom: 8px;
        }

        .api-response pre {
            background: var(--bg-input);
            border: 1px solid var(--border);
            padding: 12px;
            overflow-x: auto;
        }

        /* Responsive */
        @media (max-width: 600px) {
            html, body {
                overflow-x: hidden;
                max-width: 100vw;
            }

            .container {
                padding: 0 12px;
                max-width: 100%;
                overflow-x: hidden;
            }

            header {
                padding: 16px 0 12px;
                gap: 8px;
            }

            .header-top {
                gap: 8px;
            }

            .logo {
                font-size: 14px;
                letter-spacing: 0.2em;
            }

            .btn-menu {
                padding: 8px;
            }

            .btn-menu svg {
                width: 20px;
                height: 20px;
            }

            .header-info-row {
                gap: 6px;
            }

            .model-badge {
                font-size: 10px;
                padding: 2px 6px;
            }

            .header-info {
                font-size: 9px;
                padding: 2px 4px;
            }

            .btn-api {
                font-size: 10px;
                padding: 4px 8px;
            }

            .connection-status {
                font-size: 10px;
            }

            /* Session drawer mobile */
            .session-drawer {
                width: 85vw;
                max-width: 320px;
                left: -85vw;
            }

            .session-drawer.open {
                left: 0;
            }

            .drawer-header {
                padding: 12px;
            }

            .drawer-title {
                font-size: 11px;
            }

            .session-item {
                padding: 10px 12px;
            }

            .session-name {
                font-size: 12px;
            }

            .session-meta {
                font-size: 10px;
            }

            .message {
                font-size: 13px;
                padding: 10px 14px;
            }

            .tool-args, .tool-result-content {
                font-size: 11px;
            }

            .input-wrapper {
                flex-direction: column;
            }

            .query-input {
                font-size: 16px; /* Prevents iOS zoom on focus */
                padding: 10px 12px;
            }

            .btn {
                width: 100%;
                font-size: 13px;
                padding: 10px 16px;
            }

            .status-bar {
                font-size: 10px;
                flex-wrap: wrap;
            }

            .modal {
                padding: 10px;
            }

            .modal-content {
                padding: 16px;
                max-height: 85vh;
            }

            .modal-title {
                font-size: 14px;
            }

            .api-endpoint h3 {
                font-size: 12px;
            }

            .api-endpoint p {
                font-size: 11px;
            }

            .api-example {
                font-size: 10px;
                padding: 8px;
            }
        }

        /* Markdown rendered content */
        .message.response .markdown-content {
            white-space: normal;
        }
        .message.response .markdown-content h1,
        .message.response .markdown-content h2,
        .message.response .markdown-content h3 {
            margin: 16px 0 8px 0;
            font-weight: 600;
        }
        .message.response .markdown-content h1 { font-size: 1.4em; }
        .message.response .markdown-content h2 { font-size: 1.2em; }
        .message.response .markdown-content h3 { font-size: 1.1em; }
        .message.response .markdown-content p { margin: 8px 0; }
        .message.response .markdown-content ul,
        .message.response .markdown-content ol {
            margin: 8px 0;
            padding-left: 24px;
        }
        .message.response .markdown-content li { margin: 4px 0; }
        .message.response .markdown-content code {
            background: var(--bg-input);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .message.response .markdown-content pre {
            background: var(--bg-input);
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 12px 0;
        }
        .message.response .markdown-content pre code {
            background: none;
            padding: 0;
        }
        .message.response .markdown-content blockquote {
            border-left: 3px solid var(--neon-cyan);
            padding-left: 12px;
            margin: 8px 0;
            color: var(--text-secondary);
        }
        .message.response .markdown-content a {
            color: var(--neon-cyan);
            text-decoration: none;
        }
        .message.response .markdown-content a:hover {
            text-decoration: underline;
        }
        .message.response .markdown-content table {
            border-collapse: collapse;
            margin: 12px 0;
            width: 100%;
        }
        .message.response .markdown-content th,
        .message.response .markdown-content td {
            border: 1px solid var(--border);
            padding: 8px;
            text-align: left;
        }
        .message.response .markdown-content th {
            background: var(--bg-input);
        }

        /* Tabbed content view for HTML/Markdown */
        .tabbed-content {
            border: 1px solid var(--border);
            border-radius: 4px;
            overflow: hidden;
        }
        .tabbed-content .tab-header {
            display: flex;
            background: var(--bg-input);
            border-bottom: 1px solid var(--border);
        }
        .tabbed-content .tab-btn {
            background: none;
            border: none;
            padding: 8px 16px;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 12px;
            font-family: inherit;
            transition: all 0.2s;
        }
        .tabbed-content .tab-btn:hover {
            color: var(--text);
        }
        .tabbed-content .tab-btn.active {
            color: var(--neon-cyan);
            background: var(--bg);
            border-bottom: 2px solid var(--neon-cyan);
            margin-bottom: -1px;
        }
        .tabbed-content .tab-body {
            padding: 12px;
        }
        .tabbed-content .tab-panel {
            display: none;
        }
        .tabbed-content .tab-panel.active {
            display: block;
        }
        .tabbed-content .tab-panel.code-panel {
            background: var(--bg-input);
            white-space: pre-wrap;
            font-family: 'Fira Code', 'Consolas', monospace;
            font-size: 12px;
            overflow-x: auto;
            max-height: 400px;
            overflow-y: auto;
        }
    </style>
    <!-- Markdown-it library for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@14.1.0/dist/markdown-it.min.js"></script>
</head>
<body>
    <!-- Session Drawer -->
    <div class="session-drawer" id="session-drawer">
        <div class="drawer-header">
            <span class="drawer-title">SESSIONS</span>
            <button class="btn-new-session" id="drawer-new-btn">+ NEW</button>
        </div>
        <div class="session-list" id="session-list">
            <div class="no-sessions">No sessions yet</div>
        </div>
        <div class="drawer-footer" id="persistence-status">
            <span class="persistence-badge memory">MEMORY</span>
        </div>
    </div>
    <div class="drawer-overlay" id="drawer-overlay"></div>

    <div class="container">
        <header>
            <div class="header-row header-top">
                <button class="btn-menu" id="menu-btn" title="Sessions">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </button>
                <div class="logo">E U N I C E</div>
                <div class="header-spacer"></div>
                <button class="btn-api btn-new" id="new-btn">NEW</button>
                <div class="connection-status">
                    <div class="status-dot loading" id="status-dot"></div>
                    <span id="status-text">connecting</span>
                </div>
            </div>
            <div class="header-info-row">
                <span class="model-badge" id="model-badge">loading...</span>
                <span class="header-info" id="mode-display"></span>
                <span class="header-info" id="agent-display" style="display: none;"></span>
                <span class="header-info" id="tools-display">-</span>
                <span class="header-info" id="servers-display">-</span>
            </div>
        </header>

        <div class="messages" id="messages"></div>

        <div class="input-area">
            <div class="input-wrapper">
                <textarea
                    class="query-input"
                    id="query-input"
                    placeholder="Enter your query..."
                    rows="1"
                ></textarea>
                <button class="btn btn-cancel" id="cancel-btn">CANCEL</button>
                <button class="btn btn-primary" id="send-btn">SEND</button>
            </div>
        </div>

        <div class="status-bar" id="status-bar">
            <span id="version-display">-</span>
        </div>
    </div>

    <script>
        const messagesEl = document.getElementById('messages');
        const queryInput = document.getElementById('query-input');
        const sendBtn = document.getElementById('send-btn');
        const cancelBtn = document.getElementById('cancel-btn');
        const modelBadge = document.getElementById('model-badge');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const modeDisplay = document.getElementById('mode-display');
        const agentDisplay = document.getElementById('agent-display');
        const serversDisplay = document.getElementById('servers-display');
        const toolsDisplay = document.getElementById('tools-display');

        let isRunning = false;
        let thinkingEl = null;
        let eventSource = null;
        let currentAgent = null;  // Current agent name for multi-agent mode

        // Session management - stored in localStorage for persistence across tab closes
        // When authenticated via proxy, server handles sessions per-user automatically
        const SESSION_KEY = 'eunice_session_id';
        const SESSION_NAME_KEY = 'eunice_session_name';
        let sessionId = localStorage.getItem(SESSION_KEY);
        let authenticatedUser = null;  // Set if user is authenticated via proxy

        // Check if session name is in URL hash (e.g., /#/sprawl-molly)
        function getSessionFromUrl() {
            const hash = window.location.hash;
            if (hash && hash.startsWith('#/')) {
                return hash.substring(2);  // Remove '#/'
            }
            return null;
        }

        // Update URL to reflect current session
        function updateSessionUrl(sessionName) {
            if (sessionName) {
                window.history.replaceState(null, '', '#/' + sessionName);
            } else {
                window.history.replaceState(null, '', window.location.pathname);
            }
        }

        // Check if message content contains system instructions (DMN mode)
        function isSystemInstructionMessage(content) {
            if (!content) return false;
            // DMN instructions start with this marker
            return content.includes('# DMN: DEFAULT MODE NETWORK') ||
                   content.includes('You are now in DMN (Default Mode Network) autonomous batch mode');
        }

        // Extract user's actual prompt from a DMN-wrapped message
        function extractUserPrompt(content) {
            if (!content) return content;
            const marker = '# USER REQUEST\n\n';
            const endMarker = '\n\n---\n\nYou are now in DMN';
            const startIdx = content.indexOf(marker);
            const endIdx = content.indexOf(endMarker);
            if (startIdx !== -1 && endIdx !== -1) {
                return content.substring(startIdx + marker.length, endIdx);
            }
            return content;
        }

        // Auto-resize textarea
        queryInput.addEventListener('input', () => {
            queryInput.style.height = 'auto';
            queryInput.style.height = Math.min(queryInput.scrollHeight, 150) + 'px';
        });

        // Handle Enter key
        queryInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendQuery();
            }
        });

        sendBtn.addEventListener('click', sendQuery);
        cancelBtn.addEventListener('click', cancelQuery);

        // Fetch initial status
        async function fetchStatus() {
            try {
                const res = await fetch('/api/status');
                const data = await res.json();

                modelBadge.textContent = data.model;
                statusDot.className = 'status-dot';
                statusText.textContent = 'ready';

                // Header info
                modeDisplay.textContent = data.mode.toUpperCase();

                // Show agent name if present
                if (data.agent) {
                    currentAgent = data.agent;
                    agentDisplay.textContent = `agent: ${data.agent}`;
                    agentDisplay.style.display = 'inline';
                }

                toolsDisplay.textContent = `${data.tools_count} tools`;

                // Footer info
                serversDisplay.textContent = data.mcp_servers.length > 0
                    ? data.mcp_servers.join(', ')
                    : 'no servers';
                document.getElementById('version-display').textContent = `v${data.version}`;

                // Handle authenticated user (from proxy headers)
                if (data.authenticated_user) {
                    authenticatedUser = data.authenticated_user;
                    statusText.textContent = authenticatedUser;
                    // When authenticated, server manages sessions - don't use localStorage
                    sessionId = null;
                }
            } catch (err) {
                statusDot.className = 'status-dot disconnected';
                statusText.textContent = 'error';
            }
        }

        function addMessage(type, content) {
            const el = document.createElement('div');
            el.className = `message ${type}`;
            el.innerHTML = content;
            messagesEl.appendChild(el);
            // Use scrollIntoView for reliable autoscroll
            el.scrollIntoView({ behavior: 'instant', block: 'end' });
            return el;
        }

        function removeThinking() {
            if (thinkingEl) {
                thinkingEl.remove();
                thinkingEl = null;
            }
        }

        async function sendQuery() {
            const query = queryInput.value.trim();
            if (!query || isRunning) return;

            isRunning = true;
            sendBtn.disabled = true;
            cancelBtn.classList.add('visible');
            queryInput.value = '';
            queryInput.style.height = 'auto';

            // Add user message
            addMessage('user', escapeHtml(query));

            // Add thinking indicator
            thinkingEl = addMessage('thinking', '<span class="cursor">|</span> Thinking... <span id="thinking-time">0</span>s');

            let receivedAnyEvent = false;

            try {
                const res = await fetch('/api/query', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: query, session_id: sessionId })
                });

                // Check for HTTP errors
                if (!res.ok) {
                    removeThinking();
                    const errorText = await res.text();
                    addMessage('error', `HTTP ${res.status}: ${errorText || res.statusText}`);
                    isRunning = false;
                    sendBtn.disabled = false;
                    cancelBtn.classList.remove('visible');
                    return;
                }

                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        // Process any remaining buffer content
                        if (buffer.trim()) {
                            processSSEData(buffer);
                        }
                        break;
                    }

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        processSSEData(line);
                    }
                }

                function processSSEData(line) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === 'ping') return;

                        try {
                            const event = JSON.parse(data);
                            receivedAnyEvent = true;
                            handleEvent(event);
                        } catch (e) {
                            console.error('Parse error:', e, data);
                            // Show parse errors to user if they contain useful info
                            if (data && data.length > 0) {
                                removeThinking();
                                addMessage('error', `Parse error: ${data}`);
                            }
                        }
                    }
                }

                // If stream ended without any events, show error
                if (!receivedAnyEvent) {
                    removeThinking();
                    addMessage('error', 'Connection closed without response');
                }
            } catch (err) {
                removeThinking();
                addMessage('error', `Connection error: ${err.message}`);
            }

            isRunning = false;
            sendBtn.disabled = false;
            cancelBtn.classList.remove('visible');
            removeThinking();
        }

        function handleEvent(event) {
            switch (event.type) {
                case 'thinking':
                    const timeEl = document.getElementById('thinking-time');
                    if (timeEl) {
                        timeEl.textContent = event.elapsed_seconds;
                    }
                    break;

                case 'tool_call':
                    removeThinking();
                    const agentPrefix = currentAgent ? `<span class="tool-agent">[${escapeHtml(currentAgent)}]</span> ` : '';
                    addMessage('tool-call', `
                        ${agentPrefix}<span class="tool-name">${escapeHtml(event.name)}</span>
                        <div class="tool-args">${escapeHtml(event.arguments)}</div>
                    `);
                    // Re-add thinking for tool execution
                    thinkingEl = addMessage('thinking', '<span class="cursor">|</span> Running...');
                    break;

                case 'tool_result':
                    removeThinking();
                    const truncatedNotice = event.truncated
                        ? '<div class="truncated-notice">... output truncated</div>'
                        : '';
                    addMessage('tool-result', `
                        <div class="tool-result-content">${escapeHtml(event.result)}</div>
                        ${truncatedNotice}
                    `);
                    // Re-add thinking indicator while waiting for next LLM response
                    thinkingEl = addMessage('thinking', '<span class="cursor">|</span> Thinking... <span id="thinking-time">0</span>s');
                    break;

                case 'agent_invoke':
                    removeThinking();
                    addMessage('agent-invoke', `
                        <span class="agent-icon">ðŸ”€</span>
                        <span class="agent-label">invoking</span>
                        <span class="agent-name">${escapeHtml(event.agent_name)}</span>
                        <div class="agent-task">${escapeHtml(event.task)}</div>
                    `);
                    // Show thinking while subagent runs
                    thinkingEl = addMessage('thinking', '<span class="cursor">|</span> Agent running...');
                    break;

                case 'agent_result':
                    removeThinking();
                    const agentTruncated = event.truncated
                        ? '<div class="truncated-notice">... output truncated</div>'
                        : '';
                    addMessage('agent-result', `
                        <span class="agent-icon">âœ“</span>
                        <span class="agent-label">returned</span>
                        <span class="agent-name">${escapeHtml(event.agent_name)}</span>
                        <div class="agent-result-content">${escapeHtml(event.result)}</div>
                        ${agentTruncated}
                    `);
                    // Re-add thinking for parent agent
                    thinkingEl = addMessage('thinking', '<span class="cursor">|</span> Thinking... <span id="thinking-time">0</span>s');
                    break;

                case 'response':
                    removeThinking();
                    addMessage('response', renderContent(event.content));
                    break;

                case 'error':
                    removeThinking();
                    addMessage('error', escapeHtml(event.message));
                    break;

                case 'session_id':
                    // Store session ID from server (for new or existing sessions)
                    sessionId = event.session_id;
                    localStorage.setItem(SESSION_KEY, sessionId);
                    break;

                case 'compacted':
                    // Show compaction notice
                    addMessage('system', `Context compacted: ${escapeHtml(event.message)}`);
                    break;

                case 'done':
                    removeThinking();
                    break;
            }
        }

        async function cancelQuery() {
            try {
                await fetch('/api/cancel', { method: 'POST' });
            } catch (err) {
                console.error('Cancel error:', err);
            }
        }

        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // Initialize markdown-it
        const md = window.markdownit ? window.markdownit({
            html: true,
            linkify: true,
            typographer: true,
            breaks: true
        }) : null;

        // Detect content type: 'markdown', 'html', or 'plain'
        function detectContentType(text) {
            if (!text || typeof text !== 'string') return 'plain';

            // Check for HTML tags (but not markdown code blocks)
            const htmlTagPattern = /<(div|span|p|table|tr|td|th|ul|ol|li|h[1-6]|br|hr|img|a|strong|em|b|i)[^>]*>/i;
            const hasHtmlTags = htmlTagPattern.test(text);

            // Check for markdown patterns
            const markdownPatterns = [
                /^#{1,6}\s+.+$/m,           // Headers: # Header
                /\*\*[^*]+\*\*/,            // Bold: **text**
                /\*[^*]+\*/,                // Italic: *text*
                /`[^`]+`/,                  // Inline code: `code`
                /```[\s\S]*?```/,           // Code blocks: ```code```
                /^\s*[-*+]\s+.+$/m,         // Unordered lists: - item
                /^\s*\d+\.\s+.+$/m,         // Ordered lists: 1. item
                /\[.+\]\(.+\)/,             // Links: [text](url)
                /^\s*>\s+.+$/m,             // Blockquotes: > quote
                /^\s*\|.+\|.+\|/m,          // Tables: | col | col |
            ];

            const hasMarkdown = markdownPatterns.some(pattern => pattern.test(text));

            // If text has HTML tags and looks like intentional HTML, render as HTML
            if (hasHtmlTags && !hasMarkdown) {
                return 'html';
            }

            // If text has markdown patterns, render as markdown
            if (hasMarkdown) {
                return 'markdown';
            }

            return 'plain';
        }

        // Generate unique ID for tabbed content
        let tabbedContentId = 0;

        // Render content based on detected type with tabbed view for HTML/Markdown
        function renderContent(text) {
            const contentType = detectContentType(text);

            switch (contentType) {
                case 'markdown':
                    if (md) {
                        return createTabbedContent(text, md.render(text), 'Markdown');
                    }
                    // Fallback if markdown-it not loaded
                    return escapeHtml(text);

                case 'html':
                    // Create tabbed view for HTML content
                    return createTabbedContent(text, text, 'HTML');

                case 'plain':
                default:
                    return escapeHtml(text);
            }
        }

        // Create a tabbed content view with Preview and Code tabs
        function createTabbedContent(rawText, renderedContent, contentLabel) {
            const id = `tabbed-${++tabbedContentId}`;
            return `
                <div class="tabbed-content" id="${id}">
                    <div class="tab-header">
                        <button class="tab-btn active" data-tab="preview" onclick="switchTab('${id}', 'preview')">Preview</button>
                        <button class="tab-btn" data-tab="code" onclick="switchTab('${id}', 'code')">${contentLabel} Code</button>
                    </div>
                    <div class="tab-body">
                        <div class="tab-panel preview-panel active">${renderedContent}</div>
                        <div class="tab-panel code-panel">${escapeHtml(rawText)}</div>
                    </div>
                </div>
            `;
        }

        // Switch tabs in tabbed content
        function switchTab(containerId, tabName) {
            const container = document.getElementById(containerId);
            if (!container) return;

            // Update tab buttons
            container.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tabName);
            });

            // Update tab panels
            container.querySelectorAll('.tab-panel').forEach(panel => {
                if (tabName === 'preview') {
                    panel.classList.toggle('active', panel.classList.contains('preview-panel'));
                } else {
                    panel.classList.toggle('active', panel.classList.contains('code-panel'));
                }
            });
        }

        // NEW button reference
        const newBtn = document.getElementById('new-btn');

        // Restore session history on page load
        async function restoreSessionHistory() {
            if (!sessionId) return;

            try {
                const res = await fetch('/api/session/history', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });

                const data = await res.json();

                if (!data.exists) {
                    // Session no longer exists on server, clear local storage
                    sessionId = null;
                    localStorage.removeItem(SESSION_KEY);
                    return;
                }

                // Render each message from history
                for (const msg of data.messages) {
                    switch (msg.role) {
                        case 'user':
                            // Filter out system instructions, extract actual user prompt
                            let userContent = msg.content;
                            if (isSystemInstructionMessage(userContent)) {
                                userContent = extractUserPrompt(userContent);
                            }
                            if (userContent && userContent.trim()) {
                                addMessage('user', escapeHtml(userContent));
                            }
                            break;

                        case 'assistant':
                            // Render tool calls if present
                            if (msg.tool_calls) {
                                for (const tc of msg.tool_calls) {
                                    addMessage('tool-call', `
                                        <span class="tool-name">${escapeHtml(tc.name)}</span>
                                        <div class="tool-args">${escapeHtml(tc.arguments)}</div>
                                    `);
                                }
                            }
                            // Render content if present
                            if (msg.content) {
                                addMessage('response', renderContent(msg.content));
                            }
                            break;

                        case 'tool':
                            addMessage('tool-result', `
                                <div class="tool-result-content">${escapeHtml(msg.result)}</div>
                            `);
                            break;
                    }
                }
            } catch (err) {
                console.error('Failed to restore session history:', err);
            }
        }

        // Reconnect to live events if there's an active query
        // This allows users to close the tab and reopen to see events that happened
        async function reconnectToEvents() {
            if (!sessionId) return;

            console.log('[webapp] Reconnecting to session events:', sessionId.substring(0, 8));

            try {
                const response = await fetch('/api/session/events', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId })
                });

                if (!response.ok) {
                    console.error('[webapp] Failed to reconnect:', response.status);
                    return;
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let hasReceivedEvents = false;

                // Add "Reconnecting..." indicator if we receive events
                let reconnectingMsg = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data:')) {
                            const jsonStr = line.substring(5).trim();
                            if (jsonStr === 'ping') continue;
                            if (!jsonStr) continue;

                            try {
                                const event = JSON.parse(jsonStr);

                                // Show reconnecting message on first event (if not Done)
                                if (!hasReceivedEvents && event.type !== 'done' && event.type !== 'session_id') {
                                    hasReceivedEvents = true;
                                    reconnectingMsg = addMessage('system', 'Reconnected - replaying events from background query...');
                                    isRunning = true;
                                    submitBtn.textContent = 'Cancel';
                                    submitBtn.classList.add('cancel');
                                }

                                // Handle the event
                                handleEvent(event);

                                // If we got a done event, clean up
                                if (event.type === 'done') {
                                    isRunning = false;
                                    submitBtn.textContent = 'Send';
                                    submitBtn.classList.remove('cancel');
                                    if (reconnectingMsg) {
                                        // Update the message to show completion
                                        reconnectingMsg.innerHTML = 'Background query completed - events restored';
                                    }
                                    return;
                                }
                            } catch (parseErr) {
                                console.error('[webapp] Failed to parse event:', parseErr, jsonStr);
                            }
                        }
                    }
                }
            } catch (err) {
                console.error('[webapp] Error reconnecting to events:', err);
            }
        }

        // Session drawer elements
        const menuBtn = document.getElementById('menu-btn');
        const sessionDrawer = document.getElementById('session-drawer');
        const drawerOverlay = document.getElementById('drawer-overlay');
        const sessionList = document.getElementById('session-list');
        const drawerNewBtn = document.getElementById('drawer-new-btn');
        const persistenceStatus = document.getElementById('persistence-status');

        let currentSessionName = null;
        let persistenceEnabled = false;

        function openDrawer() {
            sessionDrawer.classList.add('open');
            drawerOverlay.classList.add('visible');
            loadSessions();
        }

        function closeDrawer() {
            sessionDrawer.classList.remove('open');
            drawerOverlay.classList.remove('visible');
        }

        menuBtn.addEventListener('click', openDrawer);
        drawerOverlay.addEventListener('click', closeDrawer);

        async function loadSessions() {
            try {
                const res = await fetch('/api/sessions');
                const data = await res.json();

                persistenceEnabled = data.persistent;

                // Update persistence badge
                const badge = persistenceStatus.querySelector('.persistence-badge');
                if (data.persistent) {
                    badge.textContent = 'PERSISTENT';
                    badge.classList.remove('memory');
                } else {
                    badge.textContent = 'MEMORY';
                    badge.classList.add('memory');
                }

                // Render session list
                if (data.sessions.length === 0) {
                    sessionList.innerHTML = '<div class="no-sessions">No sessions yet</div>';
                } else {
                    sessionList.innerHTML = data.sessions.map(session => `
                        <div class="session-item ${session.id === sessionId ? 'active' : ''}" data-id="${session.id}">
                            <div class="session-info">
                                <div class="session-name">${escapeHtml(session.name)}</div>
                                <div class="session-meta">
                                    ${session.turn_count} turns | ${session.relative_time}
                                </div>
                            </div>
                            <button class="session-delete" data-id="${session.id}" title="Delete session">&times;</button>
                        </div>
                    `).join('');

                    // Add click handlers
                    sessionList.querySelectorAll('.session-info').forEach(el => {
                        el.addEventListener('click', () => {
                            const item = el.closest('.session-item');
                            const name = item.querySelector('.session-name').textContent;
                            selectSession(item.dataset.id, name);
                        });
                    });

                    sessionList.querySelectorAll('.session-delete').forEach(el => {
                        el.addEventListener('click', (e) => {
                            e.stopPropagation();
                            deleteSession(el.dataset.id);
                        });
                    });
                }
            } catch (err) {
                console.error('[webapp] Failed to load sessions:', err);
                sessionList.innerHTML = '<div class="no-sessions">Failed to load sessions</div>';
            }
        }

        async function selectSession(id, name) {
            sessionId = id;
            currentSessionName = name;
            localStorage.setItem(SESSION_KEY, sessionId);
            localStorage.setItem(SESSION_NAME_KEY, name);
            updateSessionUrl(name);
            closeDrawer();

            // Clear messages and restore history
            messagesEl.innerHTML = '';
            await restoreSessionHistory();
        }

        async function deleteSession(id) {
            if (!confirm('Delete this session permanently?')) return;

            try {
                const res = await fetch('/api/session/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: id })
                });

                const data = await res.json();
                if (data.deleted) {
                    // If deleted current session, create new one
                    if (id === sessionId) {
                        await createNewSession();
                    }
                    loadSessions();
                }
            } catch (err) {
                console.error('[webapp] Failed to delete session:', err);
            }
        }

        async function createNewSession() {
            try {
                const res = await fetch('/api/session/new', { method: 'POST' });
                const data = await res.json();

                sessionId = data.session_id;
                currentSessionName = data.session_name;
                localStorage.setItem(SESSION_KEY, sessionId);
                localStorage.setItem(SESSION_NAME_KEY, currentSessionName);
                updateSessionUrl(currentSessionName);

                // Clear messages
                messagesEl.innerHTML = '';
                queryInput.focus();
            } catch (err) {
                console.error('[webapp] Failed to create session:', err);
            }
        }

        drawerNewBtn.addEventListener('click', async () => {
            await createNewSession();
            loadSessions();
        });

        // Update NEW button to use new session creation
        newBtn.addEventListener('click', async () => {
            if (authenticatedUser) {
                // Authenticated user - clear server-side and get new session
                try {
                    const res = await fetch('/api/session/clear', { method: 'POST' });
                    const data = await res.json();
                    if (data.cleared && data.session_id) {
                        // Update to new session from server
                        sessionId = data.session_id;
                        currentSessionName = data.session_name;
                        localStorage.setItem(SESSION_KEY, sessionId);
                        localStorage.setItem(SESSION_NAME_KEY, currentSessionName);
                        updateSessionUrl(currentSessionName);
                        console.log('[webapp] New session created:', sessionId, currentSessionName);
                    }
                } catch (err) {
                    console.error('[webapp] Failed to clear session:', err);
                }
                messagesEl.innerHTML = '';
                loadSessions(); // Refresh session list
            } else {
                await createNewSession();
            }
            queryInput.focus();
        });

        // Find session by name from server
        async function findSessionByName(name) {
            try {
                const res = await fetch('/api/sessions');
                const data = await res.json();
                return data.sessions.find(s => s.name === name);
            } catch (err) {
                console.error('[webapp] Failed to find session by name:', err);
                return null;
            }
        }

        // Initialize - check URL for session name first
        async function init() {
            await fetchStatus();

            // Check if there's a session name in URL
            const urlSessionName = getSessionFromUrl();
            if (urlSessionName) {
                console.log('[webapp] Loading session from URL:', urlSessionName);
                const session = await findSessionByName(urlSessionName);
                if (session) {
                    sessionId = session.id;
                    currentSessionName = session.name;
                    localStorage.setItem(SESSION_KEY, sessionId);
                    localStorage.setItem(SESSION_NAME_KEY, session.name);
                } else {
                    // Session not found, clear URL
                    console.log('[webapp] Session not found:', urlSessionName);
                    updateSessionUrl(null);
                }
            } else if (sessionId) {
                // Have session ID from localStorage, update URL with name
                const savedName = localStorage.getItem(SESSION_NAME_KEY);
                if (savedName) {
                    currentSessionName = savedName;
                    updateSessionUrl(savedName);
                }
            } else {
                // No session in URL or localStorage - try to load the most recent session
                try {
                    const res = await fetch('/api/sessions');
                    const data = await res.json();
                    if (data.sessions && data.sessions.length > 0) {
                        const mostRecent = data.sessions[0];
                        sessionId = mostRecent.id;
                        currentSessionName = mostRecent.name;
                        localStorage.setItem(SESSION_KEY, sessionId);
                        localStorage.setItem(SESSION_NAME_KEY, mostRecent.name);
                        updateSessionUrl(mostRecent.name);
                        console.log('[webapp] Loaded most recent session:', mostRecent.name);
                    }
                } catch (err) {
                    console.error('[webapp] Failed to fetch sessions:', err);
                }
            }

            await restoreSessionHistory();
            reconnectToEvents();
            queryInput.focus();
        }

        init();
    </script>
</body>
</html>
